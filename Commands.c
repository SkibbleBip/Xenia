/**************************************************************************
Copyright (C) 2021 SkibbleBip

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

**************************************************************************/
/***************************************************************************
* File:  Commands.c
* Author:  SkibbleBip
* Procedures:
* permittable   -checks if the inputted string contains a possible illegal
*                       content that if looked up on the internet will get the
*                       user flagged by authorities
* translateDirection    -Translates the the character abreviation of the wind
*                               direction generated by the Weather API into
*                               human readable text
* write_callback        -Callback funtion that reads data from the RESTful
*                               requests
* getRESTrequest        -function that performs the RESTful requests for the
*                               various APIs, calls the write_callback function
*                               to organize the data
* cmd_wiki      -performs the Wikipedia lookup command
* cmd_search    -performs the DuckDuckGo search command
* recursive_get -callback function called by the RESTful request function in
*                       the event that a specific answer was occured by the
*                       search command REST request, generates an list/array
*                       from related subjects encountered in the full REST
*                       response
* cmd_weather   -performs the weather lookup and compilation command
* cmd_joke      -performs the joke command
* getCommandInfo        -Decodes the inputted raw command request into a proper
*                               command by calling the parser
* beginParse    -takes in the raw command string and parses it to detect which
*                       command type it partains to and decode it into a command
***************************************************************************/
#include "Commands.h"
#include <stdlib.h>
#include <string.h>
#include <json-c/json.h>
#include <json-c/json_visit.h>



#define         NUM_OF_RESULTS          5

static json_c_visit_userfunc recursive_get;
/*define the recursive function for obtaining content from the REST request*/


/***************************************************************************
* int permittable(char* input)
* Author: SkibbleBip
* Date: 07/17/2021
* Description: Checks if the imputted text contains text which contains possible
*       illegal content. This is used to make sure the user is not attempting to
*       look up something illegal on the internet, whether intentional or not.
*
* Parameters:
*        input          I/P     char*   Text to compare for illegal content
*        permittable    O/P     int     Boolean value returned, 1 if it
*                                               contains illegal/unwanted
*                                               search content and 0 if
*                                               everything is good
**************************************************************************/
int permittable(char* input)
{
        const size_t not_allowed_len = 2;
        const char not_allowed [2][1024]        = {

        { 0x43, 0x48, 0x49, 0x4C, 0x44, 0x20, 0x50, 0x4F, 0x52, 0x4E, 0x00 },
        { 0x4A, 0x4F, 0x49, 0x4E, 0x20, 0x49, 0x53, 0x49, 0x53, 0x00 }

        };

        /*yes, I know it's awkward, but I need this list here so I can check
        * if a request contains something that might get a user flagged and
        *put on a watchlist by complete accedent
        */

        size_t input_size       =       strlen(input);

        size_t j = 0;

        for(size_t len = 0; len < not_allowed_len; len++){
                for(size_t i = 0; i < input_size; i++){
                        if(input[i] == not_allowed[len][j])
                                j++;
                        else
                                j = 0;
                        if(j == strlen(not_allowed[len]))
                                return 1;
                }
                j = 0;
        }

        /*loop through the unallowed list and check if the text contains one of
        * these unallowed words
        */

        return 0;
}


/***************************************************************************
* void translateDirection(char* code, char* out)
* Author: SkibbleBip
* Date: 07/05/2021
* Description: Translates the character representation of wind direction (NNE,
*               N, SW, etc) into English representation for speaking
*
* Parameters:
*        code   I/P     char*   The code of the direction
*        out    I/O     char*   the output of the translation
**************************************************************************/
void translateDirection(char* code, char* out)
{
        /*This is some yandere simulator type meme*/

        if(0==strcmp(code, "N"))
                strcpy(out, "North");
        else if(0==strcmp(code, "NNE"))
                strcpy(out, "North North East");
        else if(0==strcmp(code, "NE"))
                strcpy(out, "North East");
        else if(0==strcmp(code, "ENE"))
                strcpy(out, "East North East");
        else if(0==strcmp(code, "E"))
                strcpy(out, "East");
        else if(0==strcmp(code, "ESE"))
                strcpy(out, "East South East");
        else if(0==strcmp(code, "SE"))
                strcpy(out, "South East");
        else if(0==strcmp(code, "SSE"))
                strcpy(out, "South South East");
        else if(0==strcmp(code, "S"))
                strcpy(out, "South");
        else if(0==strcmp(code, "SSW"))
                strcpy(out, "South South West");
        else if(0==strcmp(code, "SW"))
                strcpy(out, "South West");
        else if(0==strcmp(code, "WSW"))
                strcpy(out, "West South West");
        else if(0==strcmp(code, "W"))
                strcpy(out, "West");
        else if(0==strcmp(code, "WNW"))
                strcpy(out, "West North West");
        else if(0==strcmp(code, "NW"))
                strcpy(out, "North West");
        else if(0==strcmp(code, "NNW"))
                strcpy(out, "North North West");
        else
                strcpy(out, "Unknown");

}

/***************************************************************************
* size_t write_callback(char *buffer, size_t size, size_t nitems, void *userdata)
* Author: SkibbleBip
* Date: 06/30/2021
* Description: callback function to read data from the RESTful request to
*               the internet
*
* Parameters:
*        buffer I/P     char*   buffer that contains the temporary data from
*                                       the request
*        size   I/P     size_t  size of the unit the array stream is in, in
*                                       bytes (since we are dealing with chars,
*                                       this is usually 1)
*        nitems I/P     size_t  number of items in the temporary buffer
*        userdata       I/O     void*   pointer to the memory chunk calculator
*                                       to store the total length of the stream
*                                       and the data in the stream
*        write_callback  O/P     size_t  size in bytes received from the call
**************************************************************************/
size_t write_callback(char *buffer, size_t size, size_t nitems, void *userdata)
{
        size_t total = size*nitems;
        struct Curl_Reply *reply = (struct Curl_Reply*)userdata;
        /*obtain the current chunk calculator from the userdata pointer*/

        char* tmp = realloc(reply->response, total + reply->size+1);
        /*obtain the new dynamic location to hold all the new incoming data*/
        if(tmp == NULL){
        /*if failed to realloc, then free the current length and return 0*/
                free(reply->response);
                return 0;
        }

        reply->response = tmp;
        /*copy the new response over*/
        memcpy(reply->response+reply->size, buffer, total);
        /*copy the new data to the response*/
        reply->size+=total;
        /*increase the size to the new length*/
        reply->response[reply->size] = '\000';
        /*null terminate it*/

        return total;
        /*return the total number of bytes read*/
}
/***************************************************************************
* char* getRESTrequest(const char* url, char* search, int8_t *err)
* Author: SkibbleBip
* Date: 07/01/2021      v1: Initial
* Date: 07/13/2021      v2: separated quieries from options
* Description: obtain the data in a RESTful request from a subject and url
*       location, and handle any errors that occur
*
* Parameters:
*        url    I/P     const char*     the url to the API that is being
*                                               performed on
*        search I/P     char*   the subject that is being looked up
*        opts   I/P     char*   options for requesting
*        err    I/O     int8_t* the error code obtained, is ERR_SUCCESS on
*                                       successful completion or other when
*                                       failed
*        getRESTrequest O/P     char*   Dynamic pointer to string that contains
*                                               the data that was contained in
*                                               the request
**************************************************************************/
char* getRESTrequest(const char* url, char* search, char* opts, int8_t *err)
{
        const int url_size      = strlen(url);
        struct Curl_Reply reply = {0, NULL};
        CURL *curl              = curl_easy_init();
        char* search_clean      = NULL;
        CURLcode res;
        int query_size;
        size_t opts_size;
        size_t clean_size;
        char* location;
        /*lengths of the url location, query subject, options, curl structs and
        *responses
        */

        curl_global_init(CURL_GLOBAL_DEFAULT);
        if(!curl){
        /*if curl failed to init, then return error*/
                *err = ERR_CURL_INIT;
                return NULL;
        }

        query_size = (search == NULL) ? 0 : strlen(search);
        opts_size  = (opts == NULL) ? 0 : strlen(opts);
        /*get the length of the options and search size, depending if they are
        *null or not
        */

        if(search != NULL){
                search_clean    = curl_easy_escape(curl, search, query_size);
                clean_size      = strlen(search_clean);
                /*clean the string (convert spaces to %20, for example)*/
        }
        else
                clean_size      = 0;

        location = malloc(url_size + opts_size + query_size +1);
        /*allocate the memory length of the url to submit a request to*/
        strcpy(location, url);
        if(search != NULL)
                strncpy(location+url_size, search_clean, clean_size+1);
        if(opts != NULL)
                strncpy(location+url_size+clean_size, opts, opts_size+1);


        /*Get the url to perform the REST request upon*/

        curl_free(search_clean);
        /*if the "cleaned" version of the search term was defined, then
        *destroy it
        */


        curl_easy_setopt(curl, CURLOPT_URL, location);
        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L); /*follow redirects*/
        curl_easy_setopt(curl, CURLOPT_USERAGENT, "Xenia/1.0");
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &write_callback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &reply);
        /*Set the options for libcurl*/

        res = curl_easy_perform(curl);
        /*perform the REST lookup*/
        if(res != CURLE_OK){
        /*if failed to request, clean up and return error*/
                curl_easy_cleanup(curl);
                curl_global_cleanup();
                free(reply.response);
                *err =  res;
                /*return Curl's error code*/
                return NULL;

        }

        curl_easy_cleanup(curl);
        curl_global_cleanup();
        /*cleanup after libcurl*/

        free(location);
        *err = ERR_SUCCESS;
        //printf(reply.response);
        return reply.response;
        /*free the dynamic location of the url, pass successful error code and
        *return the dynamic string of the response
        */

}

/***************************************************************************
* int cmd_wiki(Cmd_response_t* cmd)
* Author: SkibbleBip
* Date: 06/30/2021
* Description: function that obtains the lookup information to the RESTful call
*        to wikipedia's API and returns it
*
* Parameters:
*        cmd    I/O     Cmd_response_t  reference to the command response
*                               struct that contains the lookup info
*        cmd_wiki       O/P     int     return value of success or failure
**************************************************************************/
int cmd_wiki(Cmd_response_t* cmd)
{
        const char* url = "https://en.wikipedia.org/api/rest_v1/page/summary/";
        struct json_object *parsed;
        struct json_object *answer;
        json_bool wasFound;
        /*define variables such as url of wiki lookup REST call, and JSON
        * objects
        */

        int8_t error = 0;
        char* REST_reply = getRESTrequest(url, cmd->reply, NULL, &error);
        if(REST_reply == NULL){
                return error;
                /*if failed to return a dynamic string, return the error*/
        }
        parsed = json_tokener_parse(REST_reply);
        free(REST_reply);
        /*parse the reply from the wiki API*/
        wasFound = json_object_object_get_ex(parsed, "extract", &answer);
        /*obtain the answer from wiki by obtaining the "extract" of the reply*/

        if(!wasFound){
                json_object_put(parsed);
                /*free the parser*/
                return ERR_NOTFOUND;
        }

        const char* tmp = json_object_get_string(answer);
        /*obtain the string response of the json extract*/
        if(tmp == NULL){
        /*if NULL, then the reply was invalid*/
                json_object_put(parsed);
                /*free the parser*/
                return ERR_NOTFOUND;
        }
        free(cmd->reply);
        /*clear the previous response in case there is still remains*/
        cmd->reply = malloc(strlen(tmp)+1);
        memcpy(cmd->reply, tmp, strlen(tmp)+1);
        /*copy the answer and the null terminator to the cmd reply*/
        json_object_put(parsed);
        /*free the parser*/

        return ERR_SUCCESS;
}

/***************************************************************************
* int cmd_search(Cmd_response_t* cmd)
* Author: SkibbleBip
* Date: 07/02/2021
* Description: The search command function, curl's DuckDuckGo's web API for
*               search queries
*
* Parameters:
*        cmd    I/O     Cmd_response_t  command information and response pointer
*                                               struct
*        cmd_search     O/P     int     Error code response of the function
**************************************************************************/
int cmd_search(Cmd_response_t* cmd)
{
        struct json_object *parsed;
        struct json_object *abstract;
        struct json_object *arr;
        /*json objects for the parser and the received array, as well as the
        *abstract that will check if the abstract text is present
        */

        const char* url         =       "https://api.duckduckgo.com/?q=";
        char* opts        =       "&format=json&pretty=1&no_html=1";
        /*set up the properties for looking up the search query*/

        int8_t err;
        char* REST_reply = getRESTrequest(url, cmd->reply, opts, &err);
        ///TODO: make sure this actually works

        if(REST_reply == NULL){
                return err;
        }
        /*obtain the REST reply from DuckDuckGo and parse it, if it's not found
        *or error'd, then return with the error code
        */

        parsed  = json_tokener_parse(REST_reply);
        free(REST_reply);

        json_bool w = json_object_object_get_ex(parsed, "AbstractText", &abstract);
        const char* abstractReply = json_object_get_string(abstract);
        if(w && abstractReply[0] != '\000'){

                //printf("Text: %s\n", abstractReply);
                cmd->reply = malloc(strlen(abstractReply)+1);
                memcpy(cmd->reply, abstractReply, strlen(abstractReply)+1);
                json_object_put(parsed);
                return ERR_SUCCESS;

        }


        json_bool q = json_object_object_get_ex(parsed, "RelatedTopics", &arr);
        if(q == 0)
                return ERR_NOTFOUND;
        /*parse the json data and get the related items array and its legnth*/

        struct Json_Reply jsonReply = {0, 0, NULL};

        int error = json_c_visit(arr, 0, recursive_get, &jsonReply);
        /*run recursivly for the first 5 search queries from DuckDuckGo*/

        if(error != 0){
                return ERR_NOTFOUND;
        }
        free(cmd->reply);
        cmd->reply = jsonReply.response;


        json_object_put(parsed);
        return ERR_SUCCESS;

}

/***************************************************************************
* static int recursive_get(json_object *jso, int flags, json_object *parent_jso,
*                        const char *jso_key, size_t *jso_index, void *userarg)
* Author: SkibbleBip
* Date: 07/02/2021
* Description: callback function to recursively reading the JSON output from
*               curl and reply with the first 5 results from the request
*
* Parameters:
*        jso    I/P     json_object*    The current JSON object being processed
*        flags  I/P     int     Flag data, unused
*        parent_jso     I/P     json_object*    parent JSON object, unused
*        jso_key        I/P     const char*     The value of the JSON object
*                                                       label
*        jso_index      I/P     size_t* Index of the current JSON object, unused
*        userarg        I/O     void*   Pointer to the Json_Reply struct which
*                                               will contain the fetched replies
*                                               and their properties
*        recursive_get  O/P     int     Error code return of the function
**************************************************************************/
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
static int recursive_get(json_object *jso, int flags, json_object *parent_jso,
                        const char *jso_key, size_t *jso_index, void *userarg)
{
#pragma GCC diagnostic pop
/*shut the compiler up, we don't need these params*/

	struct Json_Reply* rp = (struct Json_Reply*)userarg;
	/*obtain the current json reply*/

	if(jso_key)
	/*only process if the key is not null*/
                if(0==strcmp(jso_key, "Text")){
                /*if the key is "Text", then process the value*/
                        if(rp->count >= NUM_OF_RESULTS)
                        /*if the count is less than the max count, then proceed
                        *otherwise tell the calling function to stop and quit
                        */
                                return JSON_C_VISIT_RETURN_STOP;

                        const char* r = json_object_to_json_string(jso);

                        char* tmp = realloc(rp->response, rp->size + strlen(r));
                        if(tmp == NULL){
                        /*if the new allocated string is null, the realloc
                        *failed, return an error
                        */
                                free(rp->response);
                                rp->count = 0;
                                rp->size  = 0;
                                return JSON_C_VISIT_RETURN_ERROR;
                        }
                        rp->response = tmp;
                        size_t len = strlen(r)-1;
                        memcpy(rp->response+rp->size, r+1, len);
                        /*copy the new string, minus the bigginning '"'
                        */
                        rp->size+=len;
                        rp->response[rp->size-1] = ' ';
                        rp->response[rp->size] = '\000';
                        rp->count++;
                        /*replace the last '"' with a space, and null terminate
                        *the current string, and increase the string length and
                        *total reply count
                        */
                }

	return JSON_C_VISIT_RETURN_CONTINUE;
}

/***************************************************************************
* int cmd_weather(Cmd_response_t* cmd)
* Author: SkibbleBip
* Date: 07/05/2021
* Description: Function for handling the weather command
*
* Parameters:
*        cmd    I/O     Cmd_response_t* The command struct to hold the response
*                                               from the weather command
*        cmd_weather    O/P     int     Error return of the function
**************************************************************************/
int cmd_weather(Cmd_response_t* cmd)
{
        //assert(cmd->reply == NULL);
        /*make sure the reply was set to null*/
        const char* url1 = "wttr.in/";
        char* url2 = "?format=j1";
        /*The API interface for the weather being used*/

        const char* lookup[] = {"FeelsLikeC", "FeelsLikeF", "humidity", "temp_C",
                "temp_F", "winddir16Point", "windspeedKmph", "windspeedMiles"};
        /*array of the JSON search terms that will be looked up in the API
        *reply
        */
        char results[8][50];
        /*array to hold the responses we want for temp, wind, etc*/

        struct json_object *parsed;
        struct json_object *condition;
        json_bool wasFound;
        /*struct for the parsed json data, the subchunk of the parsed data that
        *contains the current weather condition, and the boolean flag for
        *whether the weather was found
        */

        int8_t err;
        char* REST_reply = getRESTrequest(url1, NULL, url2, &err);
        if(REST_reply == NULL){
                return err;
        }
        /*obtain the REST response from the weather API*/

        parsed = json_tokener_parse(REST_reply);
        /*pars the reply*/

        free(REST_reply);
        /*parse the reply from the wiki API*/
        wasFound = json_object_object_get_ex(parsed, "current_condition", &condition);
        /*obtain the answer from wiki by obtaining the "extract" of the reply*/

        /*clear the previous response in case there is still remains*/
        if(!wasFound){
                json_object_put(parsed);
                /*free the parser*/
                return ERR_NOTFOUND;
        }

        struct json_object* arr = json_object_array_get_idx(condition, 0);
        /*obtain the first element of the condition array (for some reason the
        *API returns 1-element arrays)
        */

        for(int8_t i = 0; i < 8; i++){
                /*cycle through the list of request types*/
                struct json_object* current;
                wasFound = json_object_object_get_ex(arr, lookup[i], &current);
                /*get the current json object for the current search term*/

                if(!wasFound){
                /*if the object was not found, then just copy "unknown" to it's
                *place
                */
                        strcpy(results[i], "Unknown");
                }
                else{
                /*otherwise get the string literal and write it into the array*/
                        const char* t = json_object_get_string(current);
                        strncpy(results[i], t, 50);
                }

        }



        struct json_object* weatherDesc;
        struct json_object* value;
        /*JSON objects to hold the weather type and it's value(Once againt the
        *API returns a weird formatted data in single element arrays, so weird
        *processing much be done)
        */
        char condOut[100];
        /*array to hold the */

        wasFound = json_object_object_get_ex(arr, "weatherDesc", &weatherDesc);
        /*obtain the weather description (sunny, cloudy, etc) json clump.
        *this contains another single element array which contains the actual
        *value
        */
        if(!wasFound){
                strcpy(condOut, "Unknown");
        }
        else{
        /*if not found, set the value to "unknown". Otherwise nab the first
        *element from the array and then obtain it's value*/
                value = json_object_array_get_idx(weatherDesc, 0);
                if(value==NULL){
                /*if value was not found, then copy "unkown" to the output*/
                        strcpy(condOut, "Unknown");
                }
                else{
                        wasFound = json_object_object_get_ex(value, "value", &value);
                        const char* t = json_object_get_string(value);
                        strncpy(condOut, t, 100);
                        /*obtain the value, copy it to the output*/
                }
        }

        //printf("%s\n", condOut);
        char output[4096];
        char direction[20];

        translateDirection(results[5], direction);

        sprintf(output,
"The weather is %s. The tempature is %s degrees Fahrenheit, %s degrees \
Celsius. Feels like %s degrees Fahrenheit, %s degrees Celsius. Humidity is %s \
percent. Wind direction is %s. Wind speed is %s miles per hour, %s kilometers \
per hour.",
        condOut, results[4], results[3], results[1], results[0], results[2],
        direction, results[7], results[6]
);
/*this is hidious to look at, but it works. What is happening is I am sprintfing
*the strings to the hash string placeholders (%s) and then this will be used as
*a temporary */

        cmd->reply = malloc(strlen(output)+1);
        memcpy(cmd->reply, output, strlen(output)+1);
        /*copy the string into the dynamic memory pointer that is in the cmd
        *struct
        */

        json_object_put(parsed);
        /*empty the parsed object*/
        return ERR_SUCCESS;
}


/***************************************************************************
* int cmd_joke(Cmd_response_t* cmd)
* Author: SkibbleBip
* Date: 07/06/2021
* Description: Function to generate jokes from the Joke API
*
* Parameters:
*        cmd    I/O     Cmd_response_t* The reference to the command struct
*        cmd_joke       O/P     int     Error response of the function
**************************************************************************/
int cmd_joke(Cmd_response_t* cmd)
{
        free(cmd->reply);
        //assert(cmd->reply == NULL);
        /*make sure the reply was set to null*/

        const char* url  = "https://v2.jokeapi.dev/joke/";
        char* url2       = "Any?safe-mode&format=txt";
        /*the 2 parts of the url. The safe-mode arg tells the API to only give
        *family-friendly, clean jokes. The format arg for txt tells to only
        *give it in plain text
        */

        int8_t error;
        char* REST_reply = getRESTrequest(url, NULL, url2, &error);
        /*obtain the reply from the Joke API*/

        if(REST_reply==NULL){
                return error;
        }
        /*if null, there was an error and return*/

        cmd->reply = REST_reply;
        /*set the command reply to the new API reply*/

        return ERR_SUCCESS;

}


/***************************************************************************
* int getCommandInfo(Cmd_response_t* cmd)
* Author: SkibbleBip
* Date: 07/14/2021
* Description: function that decodes the voice command string into a command by
*               calling the parser
*
* Parameters:
*        cmd    I/O     Cmd_response_t* inputted struct that contains the
*                                               command string and be decoded
*                                               and returned as a command object
*        getCommandInfo O/P     int     bool flag that returns true if a
*                                               decoding was successful and
*                                               false if failed to comprehend
*                                               the command
**************************************************************************/
int getCommandInfo(Cmd_response_t* cmd)
{
        beginParse(cmd);
        /*parse the command. the cmd->reply will be altered to contain the
        *search query, if there is one
        */

        if(cmd->cmd == Unknown){
        /*if the command was unparsable, then free the string and return false*/
                free(cmd->reply);
                cmd->reply = NULL;
                return 0;
        }
        /*otherwise return true*/
        return 1;


}


/***************************************************************************
* void beginParse(Cmd_response_t* in)
* Author: SkibbleBip
* Date: 07/18/2021
* Description: function that scans the inputted raw request and decodes it into
*       a command
*
* Parameters:
*        in     I/O     Cmd_response_t* inputted raw command that will be
*                                               decoded into a proper command
**************************************************************************/
void beginParse(Cmd_response_t* in)
{
        Command_t command;
        /*the command enum that will contain the reply of the parser*/
        char* str = in->reply;
        /*get the pointer of the string*/

        toUpper(str);
        /*set the string to uppercase*/

        if(permittable(str)){
                in->cmd = Unpermittable;
                return;
        }
        /*if the command contains unpermitable content, set the command as so
        *and exit
        */

        /*************************/
        command = Look_Up(str);
        if(command == Unknown)
                command = Search_Up(str);
        if(command == Unknown)
                command = What_Is(str);
        if(command == Unknown)
                command = Tell_Me(str);
        /*Parse the command string. This will return a command enum, or
        *"Unknown" if the command was unparseable
        */

        in->cmd = command;
        /*set the command enum to the returning reference*/


}





